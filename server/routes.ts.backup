import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { z } from "zod";
import { businessInfoSchema, keywordAnalysisSchema, seoMetricsSchema, emailSignupSchema, emailLoginSchema } from "@shared/schema";
import { analyzeKeyword, editContent, enhanceIntroductionAndConclusion } from "./services/gemini";
import { preparePayment, verifyPayment, cancelPayment, getPaymentHistory } from "./services/portone";
import passport from 'passport';
import { setupAuth, requireAuth } from './auth';
import { writeOptimizedBlogPost } from "./services/anthropic";
import { searchResearch, getDetailedResearch } from "./services/perplexity";
// ì´ë¯¸ì§€ ìƒì„± ì„œë¹„ìŠ¤ ì œê±°ë¨ - ì™¸ë¶€ ë„êµ¬ ì‚¬ìš©
import { analyzeSEOOptimization, formatForMobile } from "./services/seoOptimizer";
import { enhancedSEOAnalysis } from "./services/morphemeAnalyzer";
import { TitleGenerator } from "./services/titleGenerator";

export async function registerRoutes(app: Express): Promise<Server> {
  
  // Setup authentication middleware
  setupAuth(app);
  
  // Health check endpoint should be at the top
  // Health check and ping endpoints are already handled in server/index.ts
  
  // ===== AUTHENTICATION ROUTES =====
  // Google OAuth routes are handled in auth.ts setupAuth function
  
  // ===== BLOG PROJECT ROUTES =====
  /*
  app.get('/auth/google',
    passport.authenticate('google', { scope: ['profile', 'email'] })
  );

  app.get('/auth/google/callback',
    passport.authenticate('google', { 
      successRedirect: '/',
      failureRedirect: '/login?error=google_login_failed'
    })
  );
  */

  // Kakao OAuth routes - ì†Œì…œ ë¡œê·¸ì¸ ê¸°ëŠ¥ ì¼ì‹œ ë¹„í™œì„±í™”
  /*
  app.get('/auth/kakao',
    passport.authenticate('kakao')
  );

  app.get('/auth/kakao/callback',
    passport.authenticate('kakao', { 
      successRedirect: '/',
      failureRedirect: '/login?error=kakao_login_failed'
    })
  );
  */

  // Naver OAuth routes - ì†Œì…œ ë¡œê·¸ì¸ ê¸°ëŠ¥ ì¼ì‹œ ë¹„í™œì„±í™”
  /*
  app.get('/auth/naver',
    passport.authenticate('naver')
  );

  app.get('/auth/naver/callback',
    passport.authenticate('naver', { 
      successRedirect: '/',
      failureRedirect: '/login?error=naver_login_failed'
    })
  );
  */
  
  // ===== PROTECTED ROUTES (require authentication) =====
  
  // Create new blog project
  app.post("/api/projects", async (req, res) => {
    try {
      const { keyword } = req.body;
      
      if (!keyword || typeof keyword !== "string") {
        return res.status(400).json({ error: "í‚¤ì›Œë“œë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”" });
      }

      // ì¸ì¦ ìš°íšŒ: ê¸°ë³¸ ì‚¬ìš©ì ID ì‚¬ìš©
      const project = await storage.createBlogProject({
        keyword,
        status: "keyword_analysis",
        keywordAnalysis: null,
        subtitles: null,
        researchData: null,
        businessInfo: null,
        generatedContent: null,
        seoMetrics: null,
        referenceLinks: null,
      });

      res.json(project);
    } catch (error) {
      console.error("Project creation error:", error);
      res.status(500).json({ error: "í”„ë¡œì íŠ¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Get project
  app.get("/api/projects/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getBlogProject(id);
      
      if (!project) {
        return res.status(404).json({ error: "í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      res.json(project);
    } catch (error) {
      console.error("Project fetch error:", error);
      res.status(500).json({ error: "í”„ë¡œì íŠ¸ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Analyze keyword with Gemini
  app.post("/api/projects/:id/analyze", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getBlogProject(id);
      
      if (!project) {
        return res.status(404).json({ error: "í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      const analysis = await analyzeKeyword(project.keyword);
      
      const updatedProject = await storage.updateBlogProject(id, {
        keywordAnalysis: analysis,
        subtitles: analysis.suggestedSubtitles,
        status: "keyword_analysis",
      });

      res.json(updatedProject);
    } catch (error) {
      console.error("Keyword analysis error:", error);
      res.status(500).json({ error: "í‚¤ì›Œë“œ ë¶„ì„ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Update subtitles
  app.post("/api/projects/:id/subtitles", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { subtitles } = req.body;
      
      if (!Array.isArray(subtitles) || subtitles.length !== 4) {
        return res.status(400).json({ error: "4ê°œì˜ ì†Œì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”" });
      }

      const updatedProject = await storage.updateBlogProject(id, {
        subtitles,
      });

      res.json(updatedProject);
    } catch (error) {
      console.error("Subtitle update error:", error);
      res.status(500).json({ error: "ì†Œì œëª© ì—…ë°ì´íŠ¸ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Research with Perplexity
  app.post("/api/projects/:id/research", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getBlogProject(id);
      
      if (!project || !project.subtitles) {
        return res.status(400).json({ error: "ì†Œì œëª©ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" });
      }

      const research = await searchResearch(project.keyword, project.subtitles as string[]);
      
      const updatedProject = await storage.updateBlogProject(id, {
        researchData: research,
        referenceLinks: research.citations,
        status: "business_info",
      });

      res.json(updatedProject);
    } catch (error) {
      console.error("Research error:", error);
      res.status(500).json({ error: "ìë£Œ ìˆ˜ì§‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Save business info
  app.post("/api/projects/:id/business", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const businessInfo = businessInfoSchema.parse(req.body);
      
      // Only save business info, don't change status to prevent auto-generation
      const updatedProject = await storage.updateBlogProject(id, {
        businessInfo,
        // Keep current status, don't auto-change to content_generation
      });

      res.json(updatedProject);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Business info save error:", error);
      res.status(500).json({ error: "ì—…ì²´ ì •ë³´ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Generate blog content
  app.post("/api/projects/:id/generate", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getBlogProject(id);
      
      if (!project || !project.subtitles || !project.researchData || !project.businessInfo) {
        return res.status(400).json({ error: "í•„ìš”í•œ ì •ë³´ê°€ ëª¨ë‘ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" });
      }

      // Update status to content_generation when actually starting generation
      await storage.updateBlogProject(id, {
        status: "content_generation",
      });

      // Generate content with strict morpheme requirements
      const { generateStrictMorphemeContent } = await import('./services/strictMorphemeGenerator');
      
      const generationResult = await generateStrictMorphemeContent(
        project.keyword,
        project.subtitles as string[],
        project.researchData as any,
        project.businessInfo as any,
        project.referenceBlogLinks as any,
        project.customMorphemes as string | undefined
      );
      
      let finalContent = generationResult.content;
      let seoAnalysis = generationResult.analysis;
      
      console.log(`Content generation completed in ${generationResult.attempts} attempts. Success: ${generationResult.success}`);
      
      // Enhanced optimization process with multiple stages
      console.log('Starting multi-stage optimization process');
      
      // Stage 1: Initial content optimization
      if (!generationResult.success) {
        try {
          console.log('Stage 1: Initial content optimization');
          const { optimizeMorphemeUsage } = await import('./services/morphemeOptimizer');
          const optimizedContent = await optimizeMorphemeUsage(
            finalContent,
            project.keyword,
            project.businessInfo as any
          );
          
          // Re-analyze optimized content
          const { analyzeMorphemes } = await import('./services/morphemeAnalyzer');
          const optimizedAnalysis = analyzeMorphemes(optimizedContent.optimizedContent, project.keyword);
          
          if (optimizedAnalysis.isOptimized) {
            console.log('Stage 1 successful: Content meets morpheme conditions');
            finalContent = optimizedContent.optimizedContent;
            seoAnalysis = optimizedAnalysis;
          }
        } catch (optimizationError) {
          console.error("Stage 1 optimization failed:", optimizationError);
        }
      }
      
      // Stage 2: Introduction/conclusion enhancement (only if content is already optimized)
      if (generationResult.success || seoAnalysis.isOptimized) {
        try {
          console.log('Stage 2: Introduction/conclusion enhancement');
          const enhancedContent = await enhanceIntroductionAndConclusion(
            finalContent,
            project.keyword,
            project.businessInfo as any
          );
          
          // Check if enhancement broke morpheme conditions
          const { analyzeMorphemes } = await import('./services/morphemeAnalyzer');
          const enhancedAnalysis = analyzeMorphemes(enhancedContent, project.keyword);
          
          if (enhancedAnalysis.isOptimized) {
            console.log('Stage 2 successful: Enhancement maintains morpheme conditions');
            finalContent = enhancedContent;
            seoAnalysis = enhancedAnalysis;
          } else {
            console.log('Stage 2 failed: Enhancement broke morpheme conditions, reverting');
          }
        } catch (enhancementError) {
          console.error("Stage 2 enhancement failed:", enhancementError);
        }
      } else {
        console.log('Stage 2 skipped: Content not optimized enough for enhancement');
      }

      // Don't auto-generate images, only generate content
      const updatedProject = await storage.updateBlogProject(id, {
        generatedContent: finalContent,
        seoMetrics: seoAnalysis,
        status: "completed",
      });

      res.json(updatedProject);
    } catch (error) {
      console.error("Content generation error:", error);
      res.status(500).json({ error: "ë¸”ë¡œê·¸ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Regenerate blog content
  app.post("/api/projects/:id/regenerate", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const project = await storage.getBlogProject(id);
      
      if (!project || !project.subtitles || !project.researchData || !project.businessInfo) {
        return res.status(400).json({ error: "í•„ìš”í•œ ì •ë³´ê°€ ëª¨ë‘ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤" });
      }

      // Update status to content_generation
      await storage.updateBlogProject(id, {
        status: "content_generation",
      });

      // Regenerate content with strict morpheme requirements
      const { regenerateWithStrictMorphemes } = await import('./services/strictMorphemeGenerator');
      
      const regenerationResult = await regenerateWithStrictMorphemes(
        project.generatedContent || '',
        project.keyword,
        project.subtitles as string[],
        project.researchData as any,
        project.businessInfo as any,
        project.customMorphemes as string | undefined
      );
      
      const finalContent = regenerationResult.content;
      const seoAnalysis = regenerationResult.analysis;
      
      console.log(`Content regeneration completed in ${regenerationResult.attempts} attempts. Success: ${regenerationResult.success}`);

      // Update project with regenerated content
      const updatedProject = await storage.updateBlogProject(id, {
        generatedContent: finalContent,
        seoMetrics: seoAnalysis,
        status: "completed",
      });

      res.json(updatedProject);
    } catch (error) {
      console.error("Content regeneration error:", error);
      res.status(500).json({ error: "ë¸”ë¡œê·¸ ì¬ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Copy content (normal or mobile)
  app.post("/api/projects/:id/copy", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { format } = req.body; // 'normal' or 'mobile'
      
      const project = await storage.getBlogProject(id);
      if (!project || !project.generatedContent) {
        return res.status(404).json({ error: "ìƒì„±ëœ ì½˜í…ì¸ ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      let content = project.generatedContent;
      
      if (format === 'mobile') {
        // ëª¨ë°”ì¼ìš© í¬ë§·íŒ…: 15-21ì í•œê¸€ ê¸°ì¤€, ë¬¸ë§¥ìƒ ìì—°ìŠ¤ëŸ¬ìš´ ì¤„ë°”ê¿ˆ
        content = formatContentForMobile(project.generatedContent);
      }

      res.json({ content });
    } catch (error) {
      console.error("Copy content error:", error);
      res.status(500).json({ error: "ì½˜í…ì¸  ë³µì‚¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // ëª¨ë°”ì¼ìš© ì½˜í…ì¸  í¬ë§·íŒ… í•¨ìˆ˜
  function formatContentForMobile(content: string): string {
    return content
      .split('\n')
      .map(line => {
        if (line.trim() === '') return '';
        
        // í•œê¸€ ë¬¸ì ê°œìˆ˜ ê¸°ì¤€ìœ¼ë¡œ ê³„ì‚° (ì˜ì–´, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìëŠ” 0.5ë¡œ ê³„ì‚°)
        function getKoreanLength(text: string): number {
          let length = 0;
          for (const char of text) {
            if (/[ê°€-í£]/.test(char)) {
              length += 1; // í•œê¸€ì€ 1
            } else {
              length += 0.5; // ì˜ì–´, ìˆ«ì, íŠ¹ìˆ˜ë¬¸ìëŠ” 0.5
            }
          }
          return length;
        }
        
        // 21ìë¥¼ ë„˜ìœ¼ë©´ ì¤„ë°”ê¿ˆ ì²˜ë¦¬
        if (getKoreanLength(line) > 21) {
          const segments = [];
          let currentSegment = '';
          
          // ë¬¸ì¥ ë¶€í˜¸ë‚˜ ì‰¼í‘œ ê¸°ì¤€ìœ¼ë¡œ ë¨¼ì € ë‚˜ëˆ„ê¸°
          const phrases = line.split(/([,.!?])/);
          
          for (let i = 0; i < phrases.length; i++) {
            const phrase = phrases[i];
            const testSegment = currentSegment + phrase;
            
            if (getKoreanLength(testSegment) > 21) {
              if (currentSegment.trim()) {
                segments.push(currentSegment.trim());
                currentSegment = phrase;
              } else {
                // êµ¬ë¬¸ ìì²´ê°€ ë„ˆë¬´ ê¸¸ ê²½ìš° ë‹¨ì–´ ë‹¨ìœ„ë¡œ ë¶„í• 
                const words = phrase.split(/(\s+)/);
                let wordSegment = '';
                
                for (const word of words) {
                  const testWord = wordSegment + word;
                  
                  if (getKoreanLength(testWord) > 21) {
                    if (wordSegment.trim()) {
                      segments.push(wordSegment.trim());
                      wordSegment = word;
                    } else {
                      // ë‹¨ì–´ ìì²´ê°€ ë„ˆë¬´ ê¸¸ ê²½ìš° ìì—°ìŠ¤ëŸ¬ìš´ ì§€ì ì—ì„œ ë¶„í• 
                      if (getKoreanLength(word) > 21) {
                        let charSegment = '';
                        
                        for (const char of word) {
                          if (getKoreanLength(charSegment + char) > 18) { // 15-21 ë²”ìœ„ ì¤‘ê°„ê°’
                            if (charSegment.trim()) {
                              segments.push(charSegment.trim());
                              charSegment = char;
                            }
                          } else {
                            charSegment += char;
                          }
                        }
                        
                        if (charSegment.trim()) {
                          wordSegment = charSegment;
                        }
                      } else {
                        wordSegment = word;
                      }
                    }
                  } else {
                    wordSegment += word;
                  }
                }
                
                currentSegment = wordSegment;
              }
            } else {
              currentSegment += phrase;
            }
          }
          
          if (currentSegment.trim()) {
            segments.push(currentSegment.trim());
          }
          
          return segments.join('\n');
        }
        
        return line;
      })
      .join('\n')
      .replace(/\n\s*\n/g, '\n\n'); // ë¶ˆí•„ìš”í•œ ë¹ˆ ì¤„ ì •ë¦¬
  }

  // Update reference blog links
  app.post("/api/projects/:id/reference-links", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { links } = req.body;
      
      const project = await storage.getBlogProject(id);
      if (!project) {
        return res.status(404).json({ error: "í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      await storage.updateBlogProject(id, {
        referenceBlogLinks: links
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Reference links update error:", error);
      res.status(500).json({ error: "ì°¸ê³  ë§í¬ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Update custom morphemes
  app.post("/api/projects/:id/custom-morphemes", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { customMorphemes } = req.body;
      
      const project = await storage.getBlogProject(id);
      if (!project) {
        return res.status(404).json({ error: "í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      await storage.updateBlogProject(id, {
        customMorphemes
      });

      res.json({ success: true });
    } catch (error) {
      console.error("Custom morphemes update error:", error);
      res.status(500).json({ error: "ì‚¬ìš©ì ì •ì˜ í˜•íƒœì†Œ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Chat with Gemini for content editing and title generation
  app.post("/api/projects/:id/chat", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { message } = req.body;
      
      if (!message || typeof message !== "string") {
        return res.status(400).json({ error: "ë©”ì‹œì§€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”" });
      }

      const project = await storage.getBlogProject(id);
      if (!project) {
        return res.status(404).json({ error: "í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      // Save user message
      await storage.createChatMessage({
        projectId: id,
        role: "user",
        content: message,
      });

      // Check if user is requesting title generation
      const titleKeywords = ['ì œëª©', 'íƒ€ì´í‹€', 'title', 'ì œëª© ë§Œë“¤ì–´', 'ì œëª© ìƒì„±', 'ì œëª© ì¶”ì²œ'];
      const isTitleRequest = titleKeywords.some(keyword => 
        message.toLowerCase().includes(keyword.toLowerCase())
      );

      // ì´ë¯¸ì§€ ìƒì„± ê¸°ëŠ¥ ì œê±°ë¨ - ì™¸ë¶€ ë„êµ¬ ì‚¬ìš©
      const isImageRequest = false;

      if (isTitleRequest) {
        // Title generation
        if (!project.generatedContent) {
          await storage.createChatMessage({
            projectId: id,
            role: "assistant",
            content: "ì œëª©ì„ ìƒì„±í•˜ë ¤ë©´ ë¨¼ì € ë¸”ë¡œê·¸ ì½˜í…ì¸ ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.",
          });
          return res.json({ success: true, type: 'error' });
        }

        try {
          const titleGenerator = new TitleGenerator();
          const titles = await titleGenerator.generateTitles(project.keyword, project.generatedContent);
          
          // Format titles for display
          let titleResponse = "ğŸ“ **10ê°€ì§€ ìœ í˜•ë³„ ì œëª© ì¶”ì²œ**\n\n";
          
          const typeNames = {
            general: 'ğŸ¯ ì¼ë°˜ ìƒì‹ ë°˜ë°•í˜•',
            approval: 'ğŸ‘‘ ì¸ì •ìš•êµ¬ ìê·¹í˜•',
            secret: 'ğŸ”’ ìˆ¨ê²¨ì§„ ë¹„ë°€í˜•',
            trend: 'ğŸ“ˆ íŠ¸ë Œë“œ ì œì‹œí˜•',
            failure: 'âŒ ì‹¤íŒ¨ë‹´ ê³µìœ í˜•',
            comparison: 'âš–ï¸ ë¹„êµí˜•',
            warning: 'âš ï¸ ê²½ê³ í˜•',
            blame: 'ğŸ¤ ë‚¨íƒ“ ê³µê°í˜•',
            beginner: 'ğŸ”° ì´ˆë³´ì ê°€ì´ë“œí˜•',
            benefit: 'âœ¨ íš¨ê³¼ ì œì‹œí˜•'
          };

          for (const [type, typeName] of Object.entries(typeNames)) {
            titleResponse += `${typeName}\n`;
            if (titles[type] && titles[type].length > 0) {
              titles[type].forEach((title: string, index: number) => {
                titleResponse += `${index + 1}. ${title}\n`;
              });
            }
            titleResponse += "\n";
          }

          titleResponse += "ğŸ’¡ ì›í•˜ëŠ” ì œëª©ì„ ë³µì‚¬í•´ì„œ ì‚¬ìš©í•˜ì‹œê±°ë‚˜,\níŠ¹ì • ìŠ¤íƒ€ì¼ë¡œ ë” ë§Œë“¤ì–´ë‹¬ë¼ê³  ìš”ì²­í•´ì£¼ì„¸ìš”!";

          await storage.createChatMessage({
            projectId: id,
            role: "assistant",
            content: titleResponse,
          });

          res.json({ 
            success: true, 
            type: 'title',
            titles: titles,
            message: titleResponse
          });
        } catch (titleError) {
          console.error("Title generation error:", titleError);
          await storage.createChatMessage({
            projectId: id,
            role: "assistant",
            content: "ì£„ì†¡í•©ë‹ˆë‹¤. ì œëª© ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.",
          });
          res.json({ success: true, type: 'error' });
        }
      } else if (isImageRequest) {
        // ì´ë¯¸ì§€ ìƒì„± ê¸°ëŠ¥ ì œê±°ë¨ - ì™¸ë¶€ ë„êµ¬ ì•ˆë‚´
        await storage.createChatMessage({
          projectId: id,
          role: "assistant",
          content: "ì´ë¯¸ì§€ ìƒì„±ì€ ì´ì œ ì™¸ë¶€ ë„êµ¬ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”!\n\nğŸ“¸ **Google Whisk**: https://labs.google/fx/tools/whisk\nğŸ“Š **Napkin AI**: https://www.napkin.ai/\n\nì½˜í…ì¸  ìˆ˜ì •ì´ë‚˜ ì œëª© ì œì•ˆì´ í•„ìš”í•˜ì‹œë©´ ë§ì”€í•´ì£¼ì„¸ìš”.",
        });

        res.json({ 
          success: true, 
          type: 'external_tool_guide'
        });
      } else {
        // Regular content editing
        if (!project.generatedContent) {
          return res.status(404).json({ error: "í¸ì§‘í•  ì½˜í…ì¸ ê°€ ì—†ìŠµë‹ˆë‹¤" });
        }

        // Get edited content from Gemini with SEO validation
        const { editContent } = await import("./services/gemini.js");
        const editedContent = await editContent(
          project.generatedContent,
          message,
          project.keyword,
          project.customMorphemes || undefined
        );

        // Analyze morphemes to ensure SEO conditions are met
        const { analyzeMorphemes } = await import("./services/morphemeAnalyzer.js");
        const morphemeAnalysis = analyzeMorphemes(editedContent, project.keyword, project.customMorphemes || undefined);
        
        let responseMessage = "ì½˜í…ì¸ ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.";
        if (!morphemeAnalysis.isOptimized) {
          responseMessage += `\n\nâš ï¸ SEO ìµœì í™” ìƒíƒœ:\n${morphemeAnalysis.issues.join('\n')}`;
        } else {
          responseMessage += "\n\nâœ… SEO ìµœì í™” ì¡°ê±´ì„ ë§Œì¡±í•©ë‹ˆë‹¤.";
        }

        // Save assistant message
        await storage.createChatMessage({
          projectId: id,
          role: "assistant",
          content: responseMessage,
        });

        // Update project with edited content
        const seoAnalysis = await analyzeSEOOptimization(editedContent, project.keyword);
        const updatedProject = await storage.updateBlogProject(id, {
          generatedContent: editedContent,
          seoMetrics: seoAnalysis,
        });

        res.json({ success: true, type: 'edit', project: updatedProject });
      }
    } catch (error) {
      console.error("Chat error:", error);
      res.status(500).json({ error: "ì±„íŒ… ì²˜ë¦¬ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Get chat messages
  app.get("/api/projects/:id/chat", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const messages = await storage.getChatMessages(id);
      res.json(messages);
    } catch (error) {
      console.error("Chat fetch error:", error);
      res.status(500).json({ error: "ì±„íŒ… ë‚´ì—­ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Download image
  app.get("/api/projects/:id/images/:imageIndex", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const imageIndex = parseInt(req.params.imageIndex);
      
      const project = await storage.getBlogProject(id);
      if (!project || !project.generatedImages) {
        return res.status(404).json({ error: "ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      const images = project.generatedImages as string[];
      if (imageIndex < 0 || imageIndex >= images.length || !images[imageIndex]) {
        return res.status(404).json({ error: "ì´ë¯¸ì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      const imageUrl = images[imageIndex];
      
      // Fetch the image from the URL
      const response = await fetch(imageUrl);
      if (!response.ok) {
        return res.status(404).json({ error: "ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
      }

      const imageBuffer = await response.arrayBuffer();
      
      // Set appropriate headers for download
      res.setHeader('Content-Type', 'image/png');
      res.setHeader('Content-Disposition', `attachment; filename="infographic-${project.keyword}-${imageIndex + 1}.png"`);
      res.send(Buffer.from(imageBuffer));
    } catch (error) {
      console.error("Image download error:", error);
      res.status(500).json({ error: "ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Get user business info
  app.get("/api/user/business-info", async (req, res) => {
    try {
      const userId = 1; // ì¸ì¦ ìš°íšŒ: ê¸°ë³¸ ì‚¬ìš©ì ID ì‚¬ìš©
      const businessInfos = await storage.getAllUserBusinessInfos(userId);
      res.json(businessInfos);
    } catch (error) {
      console.error("Get business info error:", error);
      res.status(500).json({ error: "ì—…ì²´ ì •ë³´ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Get all user business infos for selection
  app.get("/api/user/business-infos", async (req, res) => {
    try {
      const userId = 1; // ì¸ì¦ ìš°íšŒ: ê¸°ë³¸ ì‚¬ìš©ì ID ì‚¬ìš©
      const businessInfos = await storage.getAllUserBusinessInfos(userId);
      res.json(businessInfos);
    } catch (error) {
      console.error("Get business infos error:", error);
      res.status(500).json({ error: "ì—…ì²´ ì •ë³´ ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Create new business info
  app.post("/api/user/business-info", async (req, res) => {
    try {
      const userId = 1; // ì¸ì¦ ìš°íšŒ: ê¸°ë³¸ ì‚¬ìš©ì ID ì‚¬ìš©
      const businessInfoData = businessInfoSchema.parse(req.body);
      
      const businessInfo = await storage.createUserBusinessInfo({
        ...businessInfoData,
        userId,
      });
      
      res.json(businessInfo);
    } catch (error) {
      console.error("Create business info error:", error);
      res.status(500).json({ error: "ì—…ì²´ ì •ë³´ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Update business info by ID
  app.put("/api/user/business-info/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const businessInfoData = businessInfoSchema.parse(req.body);
      
      const businessInfo = await storage.updateUserBusinessInfoById(id, businessInfoData);
      res.json(businessInfo);
    } catch (error) {
      console.error("Update business info error:", error);
      res.status(500).json({ error: "ì—…ì²´ ì •ë³´ ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Delete business info by ID
  app.delete("/api/user/business-info/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteUserBusinessInfo(id);
      res.json({ success });
    } catch (error) {
      console.error("Delete business info error:", error);
      res.status(500).json({ error: "ì—…ì²´ ì •ë³´ ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // Generate individual image for subtitle
  app.post("/api/projects/:id/generate-image", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { subtitle, type } = req.body; // type: 'infographic' or 'photo'
      
      const project = await storage.getBlogProject(id);
      if (!project) {
        return res.status(404).json({ error: "í”„ë¡œì íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤" });
      }

      let imageUrl;
      if (type === 'infographic') {
        const { generateInfographic } = await import("./services/imageGeneration.js");
        imageUrl = await generateInfographic(subtitle, project.keyword);
      } else {
        // Generate photo-style image focused on subtitle content, not keyword
        const { generateImage } = await import("./services/imageGeneration.js");
        imageUrl = await generateImage(subtitle, "photo");
      }

      res.json({ imageUrl, subtitle, type });
    } catch (error) {
      console.error("Individual image generation error:", error);
      // Check if it's a permission error
      if (error instanceof Error && error.message.includes('Permission')) {
        res.status(503).json({ 
          error: 'Google Cloud ê¶Œí•œ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤', 
          details: 'Vertex AI User ì—­í• ì„ ì„œë¹„ìŠ¤ ê³„ì •ì— ì¶”ê°€í•´ì£¼ì„¸ìš”'
        });
      } else {
        res.status(500).json({ error: "ì´ë¯¸ì§€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
      }
    }
  });

  // Download individual image
  app.get("/api/projects/:id/download-image", async (req, res) => {
    try {
      const { imageUrl, filename } = req.query;
      
      if (!imageUrl || !filename) {
        return res.status(400).json({ error: "ì´ë¯¸ì§€ URLê³¼ íŒŒì¼ëª…ì´ í•„ìš”í•©ë‹ˆë‹¤" });
      }

      const response = await fetch(imageUrl as string);
      if (!response.ok) {
        throw new Error("ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨");
      }

      const buffer = await response.arrayBuffer();
      
      res.setHeader('Content-Type', 'image/png');
      res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
      res.send(Buffer.from(buffer));
    } catch (error) {
      console.error("Image download error:", error);
      res.status(500).json({ error: "ì´ë¯¸ì§€ ë‹¤ìš´ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤" });
    }
  });

  // ===== ê²°ì œ ê´€ë ¨ ë¼ìš°í„° =====
  
  // êµ¬ë… ê²°ì œ ì¤€ë¹„
  app.post("/api/payment/prepare", async (req, res) => {
    try {
      const { amount, name, planType } = req.body;
      
      if (!amount || !name || !planType) {
        return res.status(400).json({ error: "í•„ìˆ˜ ì •ë³´ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤." });
      }

      const paymentData = preparePayment({
        merchant_uid: `subscription_${Date.now()}`,
        amount: Number(amount),
        name: String(name),
        planType: String(planType),
      });

      res.json(paymentData);
    } catch (error) {
      console.error("Subscription preparation error:", error);
      res.status(500).json({ error: "êµ¬ë… ì¤€ë¹„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // êµ¬ë… ê²°ì œ ê²€ì¦
  app.post("/api/payment/verify", async (req, res) => {
    try {
      const { imp_uid, merchant_uid } = req.body;
      
      if (!imp_uid || !merchant_uid) {
        return res.status(400).json({ error: "ê²°ì œ ì •ë³´ê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤." });
      }

      const verificationResult = await verifyPayment({ imp_uid, merchant_uid });
      
      if (verificationResult.success) {
        // êµ¬ë… ì •ë³´ ì €ì¥ ë¡œì§ êµ¬í˜„ ì˜ˆì •
        // - ì‚¬ìš©ì êµ¬ë… í”Œëœ ì—…ë°ì´íŠ¸
        // - êµ¬ë… ì‹œì‘ì¼/ë§Œë£Œì¼ ì„¤ì •
        // - ì›”ë³„ ì‚¬ìš©ëŸ‰ ì œí•œ ì´ˆê¸°í™”
        
        res.json({ 
          success: true, 
          payment: verificationResult.payment,
          subscription: {
            plan: merchant_uid.includes('content_only') ? 'basic' :
                  merchant_uid.includes('content_and_images') ? 'premium' : 'pro',
            startDate: new Date(),
            nextBillingDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30ì¼ í›„
          }
        });
      } else {
        res.status(400).json({ 
          success: false, 
          error: verificationResult.error 
        });
      }
    } catch (error) {
      console.error("Subscription verification error:", error);
      res.status(500).json({ error: "êµ¬ë… ê²€ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ê²°ì œ ì·¨ì†Œ
  app.post("/api/payment/cancel", async (req, res) => {
    try {
      const { imp_uid, reason } = req.body;
      
      if (!imp_uid) {
        return res.status(400).json({ error: "ê²°ì œ IDê°€ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤." });
      }

      const cancelResult = await cancelPayment(imp_uid, reason);
      
      if (cancelResult.success) {
        res.json({ success: true, data: cancelResult.data });
      } else {
        res.status(400).json({ success: false, error: cancelResult.error });
      }
    } catch (error) {
      console.error("Payment cancellation error:", error);
      res.status(500).json({ error: "ê²°ì œ ì·¨ì†Œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
    }
  });

  // ê²°ì œ ë‚´ì—­ ì¡°íšŒ
  app.get("/api/payment/history", async (req, res) => {
    try {
      const historyResult = await getPaymentHistory();
      
      if (historyResult.success) {
        res.json({ success: true, payments: historyResult.payments });
      } else {
        res.status(500).json({ success: false, error: historyResult.error });
      }
    } catch (error) {
      console.error("Payment history error:", error);
      res.status(500).json({ error: "ê²°ì œ ë‚´ì—­ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤." });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
